local Metatables = {
	ServiceMT = {
		__index = function(self, index)
			local CustomIndex = self.CustomIndexs[index]
			if CustomIndex  then
				if type(CustomIndex) ~= "string" then
					return CustomIndex
				elseif not (string.find(CustomIndex, "|")) then
					return CustomIndex
				end
			end

			local GameService, Service = pcall(game.GetService, game, index)

			if GameService and (Service) and (not (type(Service) == "string")) then
				self.CachedServices[Service.ClassName] = Service
				return Service
		else
				local CustomIndex = self.CustomIndexs[index]

				if CustomIndex and type(CustomIndex) == "string" then
					CustomIndex = CustomIndex:split("|")

					local IndexParent = self.CachedServices[CustomIndex[1]]
					if not IndexParent then
						local GameService, Service = pcall(game.GetService, game, CustomIndex[1])
						if GameService and (Service) and (not (type(Service) == "string")) then
							self.CachedServices[Service.ClassName] = Service
							IndexParent = Service
						end
					end

					local CurrentPath = IndexParent
					for i = 2, #CustomIndex do
						local Success, Result = pcall(function()
							return CurrentPath[CustomIndex[i]]
						end)
						if Success then
							CurrentPath = Result
						else
							CurrentPath = nil
							break
						end
					end
					CustomIndex = CurrentPath
					self.CustomIndexs[index] = CurrentPath
				end

				return CustomIndex
			end
		end
	};
}

local Variables = setmetatable({
    CustomIndexs = {
        LocalPlayer = "Players|LocalPlayer";
        Camera      = "Workspace|CurrentCamera";
        Filter      = "Workspace|Filter";
        Events      = "ReplicatedStorage|Events";
        Grinder     = "Workspace|Map|Parts|Grinders|Grinder";
        CharStats   = "ReplicatedStorage|CharStats";

    },
    CachedServices = {}
}, Metatables.ServiceMT);

local Camera        = workspace.CurrentCamera
local Players           = Variables.Players
local RunService        = Variables.RunService
local UserInputService  = Variables.UserInputService
local TweenService      = Variables.TweenService
local GuiService        = Variables.GuiService
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer       = Variables.LocalPlayer

local LocalMouse 		= LocalPlayer:GetMouse()
local Character         = LocalPlayer.Character
local Humanoid          = Character:WaitForChild("Humanoid")
local CharacterStats    = Variables.CharStats
local SpeedConn
local LastSpeedTick     = 0

-- Esp Vars

-- Ignore duped localv lazy to implement it to the esp and replace it 

-- Main Alaska Settings

local BlackoutSettings = {
KillAura = false;
KillAuraDistance = 0;
KillAuraHeavy = false;
KillAuraNPCs = false; 
KillAuraPlayers = false;
FlingAll = false;
Walkspeed = false;
WalkspeedValue = 0;
InfiniteJump = false;
NoRecoil = false;

SilentAimRadius       = 0;
SilentAimFOVEnabled   = false;
SilentAimTargetPart   = 'Head';
SilentAimEnabled      = false;
SilentAimVisibleCheck = false;
SilentAimMaxParts     = 4;
SilentAimHitChance    = 100;


Autoshoot = false,  -- Enable or disable autoshooting
UseOffsets = false, -- Enable or disable offset shooting
ToggleNPCs = false, -- Enable or disable NPC targeting
TogglePlayers = false, -- Enable or disable player targeting
AutoshootDistance = 350,
AutoshootHitPart = 'Head',
OffsetValue  = 0,
Offset2Value = 0,
BulletTracers = false,
WallbangEnabled = false,         -- Toggle wallbang feature
WallbangDistance = 25,   
AutoReload = false, 
DeathBagESP = false,
NoRecoil = false,
InfiniteStamina = false,
AutoLoot = false,
AutoLockpick = false,
Noclip = false,
Fly = false,
Fullbright = false,
HitLogs = false,
HideLevel = false,
HideLeaderBoard = false,
	}



  
local RUNSERVICE = game:GetService("RunService");
                                            
local DRAW = Drawing.new;
local CAMERA = workspace.CurrentCamera;
local LOCAL = Players.LocalPlayer;
local VECTOR2 = Vector2.new;
local RGB = Color3.fromRGB;
local CFRAME = CFrame.new;
local MIN, MAX, ATAN2, CLAMP = math.min, math.max, math.atan2, math.clamp;
local PI, COS, SIN = math.pi, math.cos, math.sin;

local Esp = { };
Esp.RenderTime = 0;
Esp.RenderCounts = 0;
Esp.PlayerCache = { };
Esp.__Drawings = { };

Esp.Utils = { };
Esp.PlayerUtils = { };

local Client                    = LocalPlayer
local Game                      = game 
local WaitForChild              = Game.WaitForChild
local FindFirstChild            = Game.FindFirstChild
local FindFirstChildOfClass     = Game.FindFirstChildOfClass
local FindFirstChildWhichIsA    = Game.FindFirstChildWhichIsA
local IsDescendantOf            = Game.IsDescendantOf


local whitelistedPlayersAutoshoot = {}
local whitelistedPlayersSilentAim = {}

  -- Esp Settings

Esp.PlayerUtils.Settings = { 
	General = {
		DrawTeam = true; 
		EspOn = false; 
		CheckHealth = true
	};

	Box = {
		Enabled =  false; 
		Transparency = 1; 
		InlineColor = RGB(13, 105, 172); 
		OutlineColor = RGB(0, 0, 0); 
		InlineThickness = 1
	};

	Tag = {
		Enabled = false; 
		Transparency = 1; 
		InlineColor = RGB(255,255,255); 
		Font = 1; 
		Scale = 0.1; 
		Outline = true; 
		Min = 15; 
		Max = 15
	};

	Health = {
		Enabled = false; 
		OutlineColor = RGB(13, 105, 172); 
		Transparency = 1; 
		InlineColor = RGB(0, 255, 0); 
		OutlineThickness = 3; 
		Scale = 0.02; 
		Offset = 1; 
		Min = 1; 
		Max = 2;
	}; 
};


-- Esp


function Esp:Draw(Class, Properties)
	local Drawing = DRAW(Class); 
	table.insert(Esp.__Drawings, Drawing);
	if (not Properties) then return Drawing; end;

	for Property, Value in next, Properties do 
		Drawing[Property] = Value;
	end; 

	return Drawing;
end;

function Esp:Edit(Object, Properties)
	for Property, Value in next, Properties do 
		Object[Property] = Value;
	end;  
end; 

function round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end


local function GetBoundingBox(model, orientation, recursive, mustcollide) 
	if typeof(model) == "Instance" then
		model = recursive and model:GetDescendants() or model:GetChildren() 
	end
	local orientation = orientation~=nil and orientation or CFrame.new()

	local minx, miny, minz = math.huge,math.huge,math.huge
	local maxx, maxy, maxz = -math.huge,-math.huge,-math.huge

	for _, obj in pairs(model) do
		if obj:IsA("BasePart") then
			if (mustcollide==true and obj.CanCollide==false) then continue end
			cf = orientation:toObjectSpace(obj.CFrame)
			local sx, sy, sz = obj.Size.X, obj.Size.Y, obj.Size.Z

			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:components()

			local wsx = 0.5 * (math.abs(R00) * sx + math.abs(R01) * sy + math.abs(R02) * sz)
			local wsy = 0.5 * (math.abs(R10) * sx + math.abs(R11) * sy + math.abs(R12) * sz)
			local wsz = 0.5 * (math.abs(R20) * sx + math.abs(R21) * sy + math.abs(R22) * sz)

			if minx > x - wsx then
				minx = x - wsx
			end
			if miny > y - wsy then
				miny = y - wsy
			end
			if minz > z - wsz then
				minz = z - wsz
			end

			if maxx < x + wsx then
				maxx = x + wsx
			end
			if maxy < y + wsy then
				maxy = y + wsy
			end
			if maxz < z + wsz then
				maxz = z + wsz
			end
		end
	end

	local omin, omax = Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
	local omiddle = (omax+omin)*.5
	local wCf = orientation - orientation.p + orientation:pointToWorldSpace(omiddle)
	local size = (omax-omin)
	return wCf, size
end

function Esp.Utils.Get3DInstanceCorners(Object, Convert2D, Offsets)
	if (not Object) then return end; 

	local CFrame; 
	local X, Y, Z = 0, 0, 0;

	if (Object:IsA('Model')) then 
		local BoundingCFrame, Size = GetBoundingBox(Object, workspace.CurrentCamera.CFrame.Rotation, false, false)
		 CFrame = BoundingCFrame; 
		X, Y, Z = Size.X, Size.Y, Size.Z;
	else 
		CFrame = Object.CFrame; 
		X, Y, Z = Object.Size.X, Object.Size.Y, Object.Size.Z;
	end; 
	

	local Corners = {
	  CFrame * CFRAME(-X / 2, Y / 2, Z / 2),
	  CFrame * CFRAME(X / 2, Y / 2, Z / 2), 
	  CFrame * CFRAME(X / 2, -Y / 2, Z / 2), 
	  CFrame * CFRAME(-X / 2, -Y / 2, Z / 2), 
	  CFrame * CFRAME(-X / 2, Y / 2, -Z / 2),
	  CFrame * CFRAME(X / 2, Y / 2, -Z / 2),
	  CFrame * CFRAME(X / 2, -Y / 2, -Z / 2),
	  CFrame * CFRAME(-X / 2, -Y / 2, -Z / 2), 
	};

	if (Offsets) then 
		for index, offset in next, Offsets do 
			Corners[index] = Corners[index] * offset;
		end; 
	end; 

	if (Convert2D) then 
		for i, Corner in next, Corners do 
			local P = CAMERA:WorldToViewportPoint(Corner.Position);
			Corners[i] = VECTOR2(P.X, P.Y);
		end;
	end; 

	return Corners, CornerData;
end; 

function Esp.Utils.Get2DBoundingBox(Model)
	local MaxiumX, MiniumX = 0, CAMERA.ViewportSize.X;
	local MaxiumY, MiniumY = 0, CAMERA.ViewportSize.Y;
	local Corners = Esp.Utils.Get3DInstanceCorners(Model);
	local InFov = true;
  
	for _, corner in next, Corners do
	  local Point, _InFov = CAMERA.WorldToViewportPoint(CAMERA, corner.Position);
	  local X, Y = Point.X, Point.Y;
  
	  if X > MaxiumX then MaxiumX = X end;
	  if X < MiniumX then MiniumX = X end;
	  if Y > MaxiumY then MaxiumY = Y end;
	  if Y < MiniumY then MiniumY = Y end;

	  InFov = _InFov;
	end;
  
	return InFov, MiniumX, MaxiumX, MiniumY, MaxiumY;
end;

function Esp.NewStruct(Object)
	Object.Hidden = false;
	
	function Object:HideObjects(Exclusions) 
		if (self.Hidden) then return end;
		for Name, List in next, self.Drawings do 
			if (Exclusions and table.find(Exclusions, Name)) then continue; end;
			for _, Object in next, List do
				Object.Visible = false;
			end; 
		end; 
		self.Hidden = true;
	end;
end;

-- Player 
function Esp.PlayerUtils.GetTeam(Player, Character)
	return Player.Team;
end; 

function Esp.PlayerUtils.GetCharacter(Player)
	return Player.Character;
end;


function Esp.PlayerUtils.GetTagData(Player, Character, ...)
	local Tag = '';
	Tag = Tag .. Player.Name .. '\n';

	local Health, MaxHealth = Esp.PlayerUtils.GetHealth(Player, Character);
	if (Health) then Tag = Tag .. math.floor((Health / (MaxHealth or 100)) * 100) .. '%' end;

	return Tag;
end; 

function Esp.PlayerUtils.GetHealth(Player, Character)
	local Humanoid = Character:FindFirstChild('Humanoid');
	local Alive = (Humanoid and Humanoid.Health > 0);
	if (not Alive) then return false; end;
	return Humanoid.Health, Humanoid.MaxHealth;
end; 

function Esp.PlayerUtils.CreateObject(Player)
	local Data = {Player = Player; Instances = {};};
	Esp.NewStruct(Data);

	Data.PlayerName = Player.Name;
	Data.FrameTarget = 'Head';
	Data.LastFramePosition = Vector3.new(0, 0, 0);
	Data.LastFrameTime = tick();
	Data.Frames = {};

	Data.Drawings = {
		Box = {Outline = Esp:Draw('Square', {Thickness = 2; Filled = false}); Inline = Esp:Draw('Square', {Thickness = 1; Filled = false;})};
		Tag = {Bar = Esp:Draw('Square', {Filled = true; Color = RGB(30, 30, 30)}); Text = Esp:Draw('Text')};
		Health = {Outline = Esp:Draw('Square', {Filled = true}); Inline = Esp:Draw('Square', {Filled = true})};    
	};

	function Data:Destruct(Index)
		for _, List in next, self.Drawings do 
			for _, Object in next, List do 
				Object:Remove();
			end; 
		end; 
		table.remove(Esp.PlayerCache, Index);
	end;

	table.insert(Esp.PlayerCache, Data);
	return true;
end;

function Esp.PlayerUtils:UpdatePlayerCache()
	for index, Cache in next, Esp.PlayerCache do 
		local Drawings = Cache.Drawings;
		local Instances = Cache.Instances;
		local Character = self.GetCharacter(Cache.Player);
		local LocalCharacter = self.GetCharacter(LOCAL);
		local LocalTeam, PlayerTeam = self.GetTeam(LOCAL, LocalCharacter) or '0', self.GetTeam(Cache.Player, Character) or '1';

		if (not Players:FindFirstChild(Cache.PlayerName)) then 
			Cache:Destruct(index);
			continue;
		end;

		if (not Character or (not self.Settings.General.DrawTeam) and (LocalTeam == PlayerTeam)) or (not self.Settings.General.EspOn) then 
			Cache:HideObjects();
			continue; 
		end; 

		local InFov, MiniumX, MaxiumX, MiniumY, MaxiumY = Esp.Utils.Get2DBoundingBox(Character);
		local SizeX, SizeY = (MaxiumX - MiniumX), (MaxiumY - MiniumY);
		if (not InFov) then if (not InFov) then Cache:HideObjects(); continue; end; end;

		local Health, MaxHealth = self.GetHealth(Cache.Player, Character);
		Health = (Health or 0);
		MaxHealth = (MaxHealth or 120);

		if (self.Settings.General.CheckHealth and Health <= 0) then 
			Cache:HideObjects();
			continue;
		end;

		Cache.Hidden = false;


		do 
			Esp:Edit(Drawings.Box.Inline, {
				Visible = self.Settings.Box.Enabled;
				Thickness = self.Settings.Box.InlineThickness;
				Transparency = self.Settings.Box.Transparency;
				Size = VECTOR2(SizeX, SizeY); Position = VECTOR2(MaxiumX - SizeX, MaxiumY - SizeY); Color = self.Settings.Box.InlineColor})

			Esp:Edit(Drawings.Box.Outline, {
				Visible = self.Settings.Box.Enabled;
				Thickness = self.Settings.Box.OutlineThickness;
				Transparency = self.Settings.Box.Transparency;
				Size = Drawings.Box.Inline.Size; Position = Drawings.Box.Inline.Position; Color = self.Settings.Box.OutlineColor});
		end; 

		-- Health Bar 
		do 
			local Ratio = (Health / MaxHealth);
			local HealthWidth = math.clamp(SizeX * self.Settings.Health.Scale, self.Settings.Health.Min, self.Settings.Health.Max);
			local OutlineOffset = ((Drawings.Box.Outline.Thickness - Drawings.Box.Inline.Thickness) / 2);
			local FarLeft = (Drawings.Box.Inline.Position.X - OutlineOffset - self.Settings.Health.Offset)

			Esp:Edit(Drawings.Health.Inline, {
				Visible = self.Settings.Health.Enabled;
				Color = self.Settings.Health.InlineColor; 
				Size = VECTOR2(HealthWidth, -(SizeY * Ratio)); 
				Transparency = self.Settings.Health.Transparency;
				Position = VECTOR2(FarLeft - HealthWidth, MaxiumY)});
	
			Esp:Edit(Drawings.Health.Outline, {
				Visible = self.Settings.Health.Enabled;
				Color = self.Settings.Health.OutlineColor; 
				Transparency = self.Settings.Health.Transparency;
				Size = VECTOR2(HealthWidth, -(SizeY)); Position = Drawings.Health.Inline.Position});
		end;

		-- Tag 
		do 
			local Tag = self.GetTagData(Cache.Player, Character);
			Drawings.Tag.Text.Visible = self.Settings.Tag.Enabled;

			if (self.Settings.Tag.Enabled) then 
				Esp:Edit(Drawings.Tag.Text, {
					Text = (Tag);
					Color = self.Settings.Tag.InlineColor;
					Font = self.Settings.Tag.Font;
					Outline = self.Settings.Tag.Outline;
					OutlineColor = self.Settings.Tag.OutlineColor;
					Transparency = self.Settings.Tag.Transparency;
					Size = CLAMP(SizeX * self.Settings.Tag.Scale, self.Settings.Tag.Min, self.Settings.Tag.Max);
				});

				Drawings.Tag.Text.Position = VECTOR2(Drawings.Box.Inline.Position.X, Drawings.Box.Inline.Position.Y - Drawings.Tag.Text.TextBounds.Y);
			end; 
		end; 
		
	end; 
end;

function Esp:Render()
	local Time = tick();

	Esp.PlayerUtils:UpdatePlayerCache();

	self.RenderTime = RenderTime;
	self.RenderCounts = self.RenderCounts + 1; 
	return RenderTime;
end; 

--// Loading Methods UWU!!!

function Esp.PlayerUtils:DefaultLoad()
	for c, k in next, Players:GetPlayers() do if (k == LOCAL) then continue; end; Esp.PlayerUtils.CreateObject(k); end; 
	Esp.PLAYERLISTENER = Players.PlayerAdded:Connect(Esp.PlayerUtils.CreateObject);

	coroutine.wrap(function()
		while true do

			task.wait();
			Esp:Render();

		end; 
	end)();
end;

-- Load
Esp.PlayerUtils:DefaultLoad()

local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera

-- Check if workspace.Debris exists
if not workspace:FindFirstChild("Debris") then
    warn("Debris folder not found in workspace.")
    return
end

local debrisFolder = workspace.Debris:FindFirstChild("Loot")

-- Check if Loot folder exists in Debris
if not debrisFolder then
    warn("Loot folder not found in Debris.")
    return
else
    print("Loot folder found!")
end

local espList = {}

-- Function to create ESP for a Death Bag
local function createESP(part)
    -- Create the main "Death Bag" text
    local text = Drawing.new("Text")
    text.Color = Color3.fromRGB(255, 255, 255) -- White text for "Death Bag"
    text.Size = 14 -- Smaller text size
    text.Center = true
    text.Outline = true
    text.OutlineColor = Color3.new(0, 0, 0)
    text.Text = "Death Bag"
    text.Visible = false -- Start invisible

    -- Create a separate text for loot items
    local itemText = Drawing.new("Text")
    itemText.Color = Color3.fromRGB(0, 255, 0) -- Green for loot items
    itemText.Size = 12 -- Smaller text size for loot items
    itemText.Center = true
    itemText.Outline = true
    itemText.OutlineColor = Color3.new(0, 0, 0)

    -- Check the contents of the DeathBag for loot table
    local lootTable = part:FindFirstChild("LootTable")
    local itemList = "" -- To store the list of loot

    if lootTable then
        -- Ensure we loop through all items in the LootTable and display them correctly
        local hasItems = false

        for _, child in pairs(lootTable:GetChildren()) do
            if child:IsA("Instance") then
                -- Add the name of each instance (e.g. Gas Mask, Light Tactical Armor)
                itemList = itemList .. child.Name .. "\n"
                hasItems = true -- Mark that we found items
            end
        end

        -- If no items were found, display "Empty"
        if not hasItems then
            itemList = "Empty"
        end
    else
        -- If no LootTable exists, mark it as empty
        itemList = "Empty"
    end

    -- Set the item text to the list
    itemText.Text = itemList
    itemText.Visible = false -- Start invisible

    -- Store these ESP elements for updating later
    espList[part] = {
        text = text,
        itemText = itemText,
        part = part
    }

    print("Created ESP for:", part.Name, "with items:", itemList)
end

-- Function to remove ESP for a Death Bag
local function removeESP(part)
    if espList[part] then
        espList[part].text:Remove()
        espList[part].itemText:Remove()
        espList[part] = nil
        print("Removed ESP for:", part.Name)
    end
end

-- Function to update ESP visibility and positioning
local function updateESP()
    if not BlackoutSettings.DeathBagESP then
        -- Hide all ESP elements when the toggle is off
        for _, esp in pairs(espList) do
            esp.text.Visible = false
            esp.itemText.Visible = false
        end
        return
    end

    for _, esp in pairs(espList) do
        local part = esp.part
        local text = esp.text
        local itemText = esp.itemText

        -- Check if the part still exists
        if part.Parent == nil then
            removeESP(part)
            return
        end

        -- Get the screen position of the part
        local vector, onScreen = camera:WorldToViewportPoint(part.Position)

        -- Adjust visibility based on whether the part is in view
        if onScreen and vector.Z > 0 then
            text.Visible = true
            itemText.Visible = true
            -- Position the text above the death bag
            text.Position = Vector2.new(vector.X, vector.Y)
            -- Position the item text directly under the "Death Bag" text
            itemText.Position = Vector2.new(vector.X, vector.Y + 16) -- Keep items directly under the "Death Bag" text
        else
            text.Visible = false
            itemText.Visible = false
        end
    end
end

-- Detect when loot spawns and create ESP for it
debrisFolder.ChildAdded:Connect(function(child)
    if BlackoutSettings.DeathBagESP and child:IsA("MeshPart") and child.Name == "DeathBag" then
        createESP(child)
    end
end)

-- Detect when loot despawns and remove ESP
debrisFolder.ChildRemoved:Connect(function(child)
    if BlackoutSettings.DeathBagESP and espList[child] then
        removeESP(child)
    end
end)

-- Run the update loop
RunService.RenderStepped:Connect(updateESP)

-- Initial scan for existing DeathBags in the Loot folder
for _, part in pairs(debrisFolder:GetChildren()) do
    if part:IsA("MeshPart") and part.Name == "DeathBag" then
        createESP(part)
    end
end


-- Set Fps






LocalMouse.KeyDown:connect(function(key)
	if BlackoutSettings.InfiniteJump and key == " " then
		LocalPlayer.Character.Humanoid:ChangeState(3)
		wait()
	end
end)



-- Services
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

-- NPC directories
local waveSurvival_m = game.Workspace:WaitForChild("WaveSurvival").NPCs
local NPCs = workspace:WaitForChild("NPCs")
local Hostile_NPCs = NPCs:WaitForChild("Hostile")
local Other_NPCs = NPCs:WaitForChild("Other")

getgenv().killaura = {}

-- Function for hitting a target
function killaura.swinghit(t, hit)
    if BlackoutSettings.KillAuraHeavy == false then
        ReplicatedStorage.MeleeStorage.Events.Swing:InvokeServer()
    else
        ReplicatedStorage.MeleeStorage.Events.Swing:InvokeServer(true)
    end
    ReplicatedStorage.MeleeStorage.Events.Hit:FireServer(hit, hit.Position)
end

-- Function to gather characters for Kill Aura (Players & NPCs)
function gatherKillAuraTargets()
    local KillAuraChars = {}

    -- Toggle for targeting players
    if BlackoutSettings.KillAuraPlayers then
        for _, player in pairs(Players:GetPlayers()) do
            local Humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
            if Humanoid and Humanoid.Health > 1 then
                table.insert(KillAuraChars, player.Character)
            end
        end
    end

    -- Toggle for targeting NPCs
    if BlackoutSettings.KillAuraNPCs then
        -- WaveSurvival NPCs
        for _, npc in pairs(waveSurvival_m:GetChildren()) do
            local Humanoid = npc:FindFirstChild("Humanoid")
            if Humanoid and Humanoid.Health > 1 then
                table.insert(KillAuraChars, npc)
            end
        end

        -- Hostile NPCs
        for _, npc in pairs(Hostile_NPCs:GetChildren()) do
            local Humanoid = npc:FindFirstChild("Humanoid")
            if Humanoid and Humanoid.Health > 1 then
                table.insert(KillAuraChars, npc)
            end
        end

        -- Final Fight NPCs
        for _, task in pairs(workspace.ActiveTasks:GetChildren()) do
            if task.Name == "Location" and task:FindFirstChild("FinalFight") then
                for _, npc in pairs(task.FinalFight:GetChildren()) do
                    local Humanoid = npc:FindFirstChild("Humanoid")
                    if Humanoid and Humanoid.Health > 1 then
                        table.insert(KillAuraChars, npc)
                    end
                end
            end
        end
    end

    return KillAuraChars
end

-- Function to get closest character within a maximum distance
function gclosest(MaxDistance)
    local closestCharacter = nil
    MaxDistance = MaxDistance or 5000
    local localPlayerCharacter = LocalPlayer.Character

    if not localPlayerCharacter then return nil end

    local localPlayerRootPart = localPlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not localPlayerRootPart then return nil end

    local localPlayerPosition = localPlayerRootPart.Position
    local KillAuraChars = gatherKillAuraTargets()

    for _, character in pairs(KillAuraChars) do
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")

        if humanoid and humanoidRootPart and humanoid.Health > 0 then
            local distanceToTarget = (humanoidRootPart.Position - localPlayerPosition).Magnitude
            if distanceToTarget < MaxDistance then
                MaxDistance = distanceToTarget
                closestCharacter = character
            end
        end
    end

    return closestCharacter
end

-- Kill Aura with wait(0.1)
spawn(function()
    while wait(0.1) do
        if BlackoutSettings.KillAura then
            local closest = gclosest(BlackoutSettings.KillAuraDistance)
            if closest and closest:FindFirstChild("Head") then
                killaura.swinghit(BlackoutSettings.KillAuraHeavy, closest.Head)
            end
        end
    end
end)


-- Main optimization using RenderStepped for WalkSpeed and NoFallDamage
RunService.RenderStepped:Connect(function()

    -- WalkSpeed handling
    if BlackoutSettings.Walkspeed and LocalPlayer.Character then
        LocalPlayer.Character.Humanoid.WalkSpeed = BlackoutSettings.WalkspeedValue
    end

    -- No Fall Damage handling
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("RagdollClient") then
        if BlackoutSettings.NoFallDamage == true then
            LocalPlayer.Character.RagdollClient.Enabled = false
        else
            LocalPlayer.Character.RagdollClient.Enabled = true
        end
    end



if BlackoutSettings.HideLevel == true then
	game:GetService("Players").LocalPlayer.PlayerGui.MainGui.LevelFrame.Visible = false
else
	game:GetService("Players").LocalPlayer.PlayerGui.MainGui.LevelFrame.Visible = true
end

if BlackoutSettings.HideLeaderBoard == true then
	game:GetService("Players").LocalPlayer.PlayerGui.MainStaticGui.RightTab.Visible = false
else
	game:GetService("Players").LocalPlayer.PlayerGui.MainStaticGui.RightTab.Visible = true
end
end)







-- // Silent Aim // --


local ValidTargetParts = {"Head", "HumanoidRootPart"}
local ValidTargetParts2 = {"HumanoidRootPart", 'Left Arm' , 'Right Arm'}
local Camera        = workspace.CurrentCamera
local Players       = game:GetService("Players")
local RunService    = game:GetService("RunService")

local LocalPlayer   = Players.LocalPlayer
local Mouse         = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local WorldToScreen = Camera.WorldToScreenPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild


local function getPositionOnScreen(Vector)
	local Vec3, OnScreen = WorldToScreen(Camera, Vector)
	return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
	local Matches = 0
	if #Args < RayMethod.ArgCountRequired then
		return false
	end
	for Pos, Argument in next, Args do
		if typeof(Argument) == RayMethod.Args[Pos] then
			Matches = Matches + 1
		end
	end
	return Matches >= RayMethod.ArgCountRequired
end


function CalculateChance(Percentage)

    Percentage = math.floor(Percentage)

    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100

    return chance <= Percentage / 100
end

local function getDirection(Origin, Position)
	return (Position - Origin).Unit * 1000
end

local function IsPlayerVisible(Player)
	local PlayerCharacter = Player.Character
	local LocalPlayerCharacter = LocalPlayer.Character

	if not (PlayerCharacter or LocalPlayerCharacter) then return end

	local PlayerRoot = FindFirstChild(PlayerCharacter, BlackoutSettings.SilentAimTargetPart) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")

	if not PlayerRoot then return end

	local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
	local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)

	return ObscuringObjects <= BlackoutSettings.SilentAimMaxParts
end

local function getClosestPlayer()
	local Closest
	local DistanceToMouse
	for _, Player in next, GetChildren(Players) do
		if Player == LocalPlayer then continue end

		local Character = Player.Character
		if not Character then continue end

		if BlackoutSettings.SilentAimVisibleCheck and not IsPlayerVisible(Player) then continue end

		local HumanoidRootPart  = FindFirstChild(Character, "HumanoidRootPart")
		local Humanoid          = FindFirstChild(Character, "Humanoid")
		local Head              = FindFirstChild(Character, "Head")

		if not HumanoidRootPart or not Humanoid or not Head or Humanoid and Humanoid.Health <= 0 then continue end

		local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)

		if not OnScreen then continue end

		local Distance = (Vector2.new(Mouse.X, Mouse.Y) - ScreenPosition).Magnitude
		if Distance <= (DistanceToMouse or (BlackoutSettings.SilentAimFOVEnabled and BlackoutSettings.SilentAimRadius) or 2000) then
			Closest = ((BlackoutSettings.SilentAimTargetPart == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or ((BlackoutSettings.SilentAimTargetPart == "Random2" and Character[ValidTargetParts2[math.random(1, #ValidTargetParts2)]]) or Character[BlackoutSettings.SilentAimTargetPart]))
			DistanceToMouse = Distance
		end
	end
	return Closest
end

local fov_circle = Drawing.new("Circle") do
	fov_circle.Thickness = 0.7
	fov_circle.NumSides = 100
	fov_circle.Radius = BlackoutSettings.SilentAimRadius
	fov_circle.Filled = false
	fov_circle.Visible = false
	fov_circle.ZIndex = 999
	fov_circle.Transparency = 1
	fov_circle.Color = Color3.fromRGB(255,255,255)

	coroutine.resume(coroutine.create(function()
		RunService.RenderStepped:Connect(function()
			fov_circle.Visible = BlackoutSettings.SilentAimFOVEnabled
			if fov_circle.Visible then
				fov_circle.Radius   = BlackoutSettings.SilentAimRadius
				fov_circle.Position = Vector2.new(Mouse.X, Mouse.Y) + Vector2.new(0, 36)
			end
		end)
	end))
end

local raycastArguments = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
	local Method    = getnamecallmethod()
	local Caller    = tostring(getcallingscript())
	local Arguments = {...}
	local self      = Arguments[1]
	local chance = CalculateChance(BlackoutSettings.SilentAimHitChance)

	if BlackoutSettings.SilentAimEnabled and Method == "Raycast" and self == workspace and chance == true then
		if ValidateArguments(Arguments, raycastArguments) then
			local A_Origin = Arguments[2]

			local HitPart = getClosestPlayer()
			if HitPart then


				Arguments[3] = getDirection(A_Origin, HitPart.Position)

				return oldNamecall(unpack(Arguments))
			end
	end
	end
	return oldNamecall(...)
end)






local raycastArguments = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(BlackoutSettings.SilentAimHitChance)

    if BlackoutSettings.SilentAimEnabled and Method == "Raycast" and self == workspace and chance == true then
        if ValidateArguments(Arguments, raycastArguments) then
            local A_Origin = Arguments[2]
            local HitPart = getClosestPlayer()

            if HitPart then
                Arguments[3] = getDirection(A_Origin, HitPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        end
    end
    return oldNamecall(...)
end)



-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- Variables
local localPlayer = Players.LocalPlayer
local gunStorage = ReplicatedStorage:WaitForChild("GunStorage")
local events = gunStorage:WaitForChild("Events")
local shootEvent = events:WaitForChild("Shoot")
local hitEvent = events:WaitForChild("Hit")
local shootCooldown = 1 -- Cooldown in seconds
local lastShotTime = 0 -- Timestamp of the last shot
local gunStatus = nil -- To store gun status after check

-- Gun check function (ammo, gun status, ray value)
local function checkGunStatus()
    local character = localPlayer.Character
    if not character then return false end

    local gunModel = character:FindFirstChild("ServerGunModel")
    if not gunModel then return false end

    local gunBody = gunModel:FindFirstChild("Body") or gunModel:FindFirstChild("Base")
    if not gunBody or not gunBody:IsA("BasePart") then
        print("Gun body or base part not found!")
        return false
    end

    local playerCharacter = Workspace.Chars:FindFirstChild(localPlayer.Name)
    if not playerCharacter then
        print("Player character not found in Workspace.Chars")
        return false
    end

    local rayValue = playerCharacter:FindFirstChildOfClass("RayValue")
    if not rayValue then
        print("RayValue not found for player!")
        return false
    end

    local gunFolder = playerCharacter:FindFirstChild(rayValue.Name)
    if not gunFolder then
        print("Weapon folder not found for:", rayValue.Name)
        return false
    end

    local status = gunFolder:FindFirstChild("GunStatus")
    if not status then
        print("GunStatus not found!")
        return false
    end

    -- Check ammo/magazine
    local magazine = status:GetAttribute("Magazine")
    if not magazine then
        print("Cannot shoot: Magazine attribute not found.")
        return false
    elseif magazine <= 0 then
        return "no_ammo" -- Return 'no_ammo' if no ammo is left
    end

    -- Cache gunStatus
    gunStatus = {
        gunModel = gunModel,
        gunBody = gunBody,
        rayValue = rayValue,
        status = status,
        magazine = magazine
    }

    return true
end

-- Ensure bullets folder exists
local function ensureBulletsFolder()
    local camera = Workspace.CurrentCamera
    local bulletsFolder = camera:FindFirstChild("Bullets")
    if not bulletsFolder then
        bulletsFolder = Instance.new("Folder")
        bulletsFolder.Name = "Bullets"
        bulletsFolder.Parent = camera
    end
    return bulletsFolder
end

-- Visualize bullet tracer
local function visualizeBullet(origin, position)
    local bulletsFolder = ensureBulletsFolder()


	
    local direction = (position - origin).Unit
    local distance = (position - origin).Magnitude

    local part = Instance.new("Part", bulletsFolder)
    part.Size = Vector3.new(0.1, 0.1, distance)
    part.Anchored = true
    part.CanCollide = false
    part.CFrame = CFrame.new(origin + direction * (distance / 2), position)
    part.Transparency = 1

    local attachment0 = Instance.new("Attachment", part)
    attachment0.Position = Vector3.new(0, 0, -distance / 2)
    
    local attachment1 = Instance.new("Attachment", part)
    attachment1.Position = Vector3.new(0, 0, distance / 2)

    local beam = Instance.new("Beam", part)
    beam.FaceCamera = true
    beam.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(13, 105, 172)),
		ColorSequenceKeypoint.new(1, Color3.fromHSV(tick()%4/5,1,1)),
    })

    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
	beam.LightEmission = 10
    beam.LightInfluence = 10
    beam.Width0 = 3
    beam.Width1 = 3
    beam.Texture = "http://www.roblox.com/asset/?id=446111271"
    beam.TextureSpeed = 0.5
    beam.TextureLength = 1
    beam.ZOffset = -1

    delay(2, function()
        for i = 0.5, 1, 0.02 do
            wait()
            beam.Transparency = NumberSequence.new(i)
        end
        part:Destroy()
    end)
end

-- Check if the target is in forcefield
local function isInForcefield(character)
    return character:FindFirstChildOfClass("ForceField") ~= nil
end

-- Check if the target is alive
local function isAlive(character)
    local humanoid = character:FindFirstChild("Humanoid")
    return humanoid and humanoid.Health > 0
end

-- Define raycast parameters once for efficiency
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.IgnoreWater = true

-- Caching the player's character to avoid repeated lookups
local playerCharacter = localPlayer.Character

-- Function to check if the target is visible
local function isTargetVisible(gunPosition, target)
    local direction = (target.Position - gunPosition).Unit
    local distance = (target.Position - gunPosition).Magnitude
    
    -- Only update the filter if the player's character changes
    if raycastParams.FilterDescendantsInstances[1] ~= playerCharacter then
        raycastParams.FilterDescendantsInstances = {playerCharacter}
    end
    
    -- Cast the ray
    local result = Workspace:Raycast(gunPosition, direction * distance, raycastParams)

    -- If there's a hit, check if it's part of the target
    if result then
        return result.Instance:IsDescendantOf(target.Parent)
    else
        return true -- No obstruction, target is visible
    end
end

-- Get the closest target from the gun's position
local function GetClosestFromGun(gunPosition, maxDistance)
    local closestTarget = nil
    maxDistance = maxDistance or 100

    if BlackoutSettings.ToggleNPCs then
        local npcGroups = {
            Workspace.NPCs.Hostile:GetChildren(),
            Workspace.NPCs.Custom:GetChildren(),
            Workspace.WaveSurvival.NPCs:GetChildren()
        }

        for _, group in ipairs(npcGroups) do
            for _, npc in pairs(group) do
                local targetPart = npc:FindFirstChild('Head') -- Find the specified hit part
                if targetPart and isAlive(npc) then
                    local distanceToNPC = (targetPart.Position - gunPosition).Magnitude
                    if distanceToNPC < maxDistance then
                        maxDistance = distanceToNPC
                        closestTarget = targetPart
                    end
                end
            end
        end
    end

    if BlackoutSettings.TogglePlayers then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local targetPart = player.Character:FindFirstChild('Head') -- Find the specified hit part
                if targetPart and isAlive(player.Character) and not isInForcefield(player.Character) then
                    local distanceToPlayer = (targetPart.Position - gunPosition).Magnitude
                    if distanceToPlayer < maxDistance then
                        maxDistance = distanceToPlayer
                        closestTarget = targetPart
                    end
                end
            end
        end
    end

    return closestTarget
end

-- Shoot target
local function shootTarget(origin, target)
    local gunModel = localPlayer.Character:FindFirstChild("ServerGunModel")
    if not gunModel then return end

    local gunBody = gunModel:FindFirstChild("Body") or gunModel:FindFirstChild("Base")
    if not gunBody or not gunBody:IsA("BasePart") then return end

    local gunPosition = gunBody.Position

    -- Determine the part to shoot at
    local hitPart = target.Parent:FindFirstChild('Head') -- Use the configured hit part
    if not hitPart then return end  -- Exit if the specified part doesn't exist

    local args = {gunPosition, CFrame.new(gunPosition, hitPart.Position), 1, 1, math.huge, math.huge}
    
    -- Fire the shoot event
    shootEvent:FireServer(unpack(args))
    
    -- Fire the hit event for the specified hit part
    hitEvent:FireServer(hitPart, math.huge)

    -- Visualize the bullet if bullet tracers are enabled
    if BlackoutSettings.BulletTracers then
        visualizeBullet(origin, hitPart.Position)
    end
end

-- Wallbang target
local function wallbangTarget(origin, target)
    shootTarget(origin, target)
    print("Shot fired through wall at target:", target.Position)
end


-- Tracer setup
local tracer = Drawing and Drawing.new("Line") or nil
if tracer then
    tracer.Thickness = 1.3
    tracer.Color = Color3.fromRGB(255, 0, 0) -- Red by default
    tracer.Visible = false
end

-- Update tracer
local function updateTracer(target, isVisible, inWallbangRadius, noAmmo)
    if not tracer then return end

    if target and gunStatus then
        local targetPart = target.Parent:FindFirstChild('Head') -- Find the target part
        if targetPart then
            local targetPosition = Workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
            if targetPosition.Z > 0 then
                local screenCenter = Vector2.new(Workspace.CurrentCamera.ViewportSize.X / 2, Workspace.CurrentCamera.ViewportSize.Y / 2)
                tracer.From = screenCenter
                tracer.To = Vector2.new(targetPosition.X, targetPosition.Y)

                if noAmmo then
                    tracer.Color = Color3.fromRGB(255, 165, 0) -- Orange when no ammo
                elseif inWallbangRadius then
                    tracer.Color = Color3.fromRGB(0, 255, 0) -- Green in wallbang range
                elseif isVisible then
                    tracer.Color = Color3.fromRGB(0, 255, 0) -- Green when visible
                else
                    tracer.Color = Color3.fromRGB(255, 0, 0) -- Red when not visible
                end
                tracer.Visible = true
            else
                tracer.Visible = false -- Hide tracer if target is behind
            end
        else
            tracer.Visible = false -- Hide tracer if no target part found
        end
    else
        tracer.Visible = false -- Hide tracer if no target or no gun status
    end
end

-- Main Target Check Function (including cooldown, forcefield, alive checks, and tracer handling)
local function CheckTarget()
    local currentTime = tick()
    if currentTime - lastShotTime < shootCooldown then
        return -- Exit if the cooldown isn't finished
    end

    -- Check gun status before proceeding
    local gunCheckResult = checkGunStatus()
    if gunCheckResult == "no_ammo" then
        -- Tracer turns orange if no ammo
        updateTracer(nil, false, false, true)
        return
    elseif not gunCheckResult then
        -- Hide tracer if no gun or other status issues
        updateTracer(nil, false, false, false)
        return
    end

    local gunPosition = gunStatus.gunBody.Position
    local closestTarget = GetClosestFromGun(gunPosition, BlackoutSettings.AutoshootDistance)
    
    if closestTarget then
        local distanceToTarget = (closestTarget.Position - gunPosition).Magnitude
        local inWallbangRadius = BlackoutSettings.WallbangEnabled and distanceToTarget <= BlackoutSettings.WallbangDistance
        local visible = isTargetVisible(gunPosition, closestTarget)

        updateTracer(closestTarget, visible, inWallbangRadius, false)

        if inWallbangRadius then
            wallbangTarget(gunPosition, closestTarget)
            lastShotTime = currentTime
        elseif visible then
            shootTarget(gunPosition, closestTarget)
            lastShotTime = currentTime
        end
    else
        updateTracer(nil, false, false, false)
    end
end

-- Main loop
RunService.RenderStepped:Connect(function()
    if BlackoutSettings.Autoshoot then
        CheckTarget()
    end
end)




 -- No recoil

 local NewIndex
NewIndex = hookmetamethod(game, "__newindex", function(self, Property, Value)
    if not checkcaller() then
        -- Prevent camera recoil by locking CFrame
        if BlackoutSettings.NoRecoil and self == workspace.CurrentCamera and Property == "CFrame" then
            -- Traceback to find the recoil update during RenderStepped
            local Traceback = debug.traceback()

            -- If recoil update is detected, lock camera CFrame
            if Traceback:find("RenderSteppedUpdate", 1, true) or Traceback:find("ScreenShake") then
                -- Return the existing CFrame to prevent recoil
                return
            end
        end
    end

    return NewIndex(self, Property, Value)
end)




-- Infinite Stamina

local Namecall
Namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()
    local ExecutorCall = checkcaller()

    if not ExecutorCall then
        -- Hooking GetAttribute method for Stamina
        if BlackoutSettings.InfiniteStamina and Method == "GetAttribute" then
            if Args[1] == "Stamina" then
                return 100
            end
        end

        -- Hooking FireServer method for Stamina
        if Method == "FireServer" then
            if self.Name == "Stamina" then
                return
            end
        end
    end

    return Namecall(self, ...)
end)











-- Instant Lockpick

local Module
for Index, Value in next, getgc(true) do 
    if type(Value) == "table" and rawget(Value, "Lockpick") and type(rawget(Value, "Lockpick")) == "function" then 
        Module = Value
    end
end 

local Lockpick = Module.Lockpick

Module.Lockpick = function(...)
    if not BlackoutSettings.AutoLockpick then
        return Lockpick(...)
    end
    
    local Args = {...}
    local Object = Args[2]

    -- Instantly complete the lockpick minigame
    ReplicatedStorage.Events.Loot.MinigameResult:FireServer(Object, true)

    task.wait(0.4)
    keypress(0x45)  -- Simulates pressing the "E" key
    return Lockpick(...)
end






-- AutoLoot



-- Define necessary services and objects
local ProxPromptService = game:GetService("ProximityPromptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Client = game.Players.LocalPlayer

-- Proximity prompts handler
ProxPromptService.PromptButtonHoldBegan:Connect(function(Prompt, Player)
    if not BlackoutSettings.AutoLoot then
        return
    end

    -- Ensure the player interacting is the client
    if Player == Client then
        -- Instantly interact with proximity prompts
        fireproximityprompt(Prompt)
    end

    -- Instantly loot cash if the prompt corresponds to a lootable object
    if Prompt.Name == "OpenLootTable" and Prompt.Parent:FindFirstChild("LootTable") then
        ReplicatedStorage.Events.Loot.LootObject:FireServer(Prompt.Parent:FindFirstChild("LootTable"), "Cash")
        ReplicatedStorage.Events.Loot.LootObject:FireServer(Prompt.Parent:FindFirstChild("LootTable"), "Valuables")
    end
end)





-- Noclip


local function NoclipLoop()
    if BlackoutSettings.Noclip and LocalPlayer.Character ~= nil then
        for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
            if child:IsA("BasePart") and child.CanCollide == true then
                child.CanCollide = false
            end
        end
    end
end
Noclipping = game:GetService('RunService').Stepped:Connect(NoclipLoop)
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer

-- Variables
local flying = false
local speed = 50 -- Adjust the fly speed
local verticalSpeed = 5 -- Speed for going up and down (E and Q)
local flyLoop
local character
local humanoidRootPart

-- Reuse BodyVelocity object without creating new instances
local BodyVelocity = Instance.new("BodyVelocity")
BodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
BodyVelocity.Parent = nil -- Initially not attached

-- Reuse BodyGyro to keep the character's orientation stable
local BodyGyro = Instance.new("BodyGyro")
BodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
BodyGyro.P = 3000
BodyGyro.CFrame = workspace.CurrentCamera.CFrame
BodyGyro.Parent = nil -- Initially not attached

-- Function to start or stop flying
local function setFlyState(enable)
    if enable and not flying then
        flying = true
        BodyVelocity.Parent = humanoidRootPart -- Attach velocity when flying starts
        BodyGyro.Parent = humanoidRootPart -- Attach gyro to maintain orientation

        flyLoop = RunService.Heartbeat:Connect(function()
            local moveDirection = Vector3.new()

            -- W, A, S, D movement controls while flying
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + (workspace.CurrentCamera.CFrame.LookVector)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - (workspace.CurrentCamera.CFrame.LookVector)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - (workspace.CurrentCamera.CFrame.RightVector)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + (workspace.CurrentCamera.CFrame.RightVector)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.E) then
                moveDirection = moveDirection + Vector3.new(0, verticalSpeed, 0) -- Fly up
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                moveDirection = moveDirection - Vector3.new(0, verticalSpeed, 0) -- Fly down
            end

            -- Apply velocity based on input
            BodyVelocity.Velocity = moveDirection * speed
            BodyGyro.CFrame = workspace.CurrentCamera.CFrame -- Maintain character orientation
        end)

    elseif not enable and flying then
        flying = false
        BodyVelocity.Parent = nil -- Detach velocity when flying stops
        BodyGyro.Parent = nil -- Detach gyro
        if flyLoop then flyLoop:Disconnect() end
    end
end

-- Function to setup flying after character respawn
local function setupCharacter(character)
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Resume flying if it was enabled before death
    if flying then
        setFlyState(true)
    end
end

-- Bind character to fly function on respawn
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    setupCharacter(character)
end)

-- Handle current character
if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end

-- Function to toggle flying on pressing F only when BlackoutSettings.Fly is true
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.F and not gameProcessed and BlackoutSettings.Fly then
        setFlyState(not flying) -- Toggle flying state
    end
end)


-- // Start // --


--// Original Size UI //--

--local AlaskaModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/NougatBitz/AlaskaEternal/main/UI"))()



--// Modified UI //--
local AlaskaModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/nullputr-web/haggdgweqf/refs/heads/main/anothertestlololol"))()
local Library = AlaskaModule.new({
    Title = "",
    Icon = "rbxassetid://0",
    Parent = game.CoreGui,
    ToggleKey = Enum.KeyCode.End
})




-- // Tabs // --

-- // Tabs // --

local VisualsTab = Library.Tabs.new({
    Title = "Visuals",
    Icon = "rbxassetid://10403490626"
})

local CombatTab = Library.Tabs.new({
    Title = "Weapon",
    Icon = "rbxassetid://132485648552802"
})
--rbxassetid://10401329089



local ExploitsTab = Library.Tabs.new({
    Title = "Exploits",
    Icon = "rbxassetid://116424921513573"

})


local MiscTab = Library.Tabs.new({
    Title = "Misc",
    Icon = "rbxassetid://112253400449843"
})



-- // Visuals Tab Start // --


-- // Player Esp // --



local VisualsTab2 = VisualsTab:Groupbox({
	Title = "World Visuals",
	Side = 2
})
local VisualsTab = VisualsTab:Groupbox({
    Title = "Player Visuals",
    Side = 1
})







VisualsTab:CreateObject(function(Type, Flag, Value, Selected)
	Esp.PlayerUtils.Settings.General.EspOn = Value
	end, {
		{
		Type = "Toggle",
		Default = false,
		Flag = "Toggle"
	}, {
		Type = "Label",
		Text = "Toggle Esp"
	},
	})
	
	VisualsTab:CreateObject(function(Type, Flag, Value, Selected)
		Esp.PlayerUtils.Settings.Tag.Enabled = Value
		end, {
			{
			Type = "Toggle",
			Default = false,
			Flag = "Toggle"
		}, {
			Type = "Label",
			Text = "Show Info"
		},
		})
	
		VisualsTab:CreateObject(function(Type, Flag, Value, Selected)
			Esp.PlayerUtils.Settings.Box.Enabled = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Show Box"
			},
			})
	
	
			VisualsTab:CreateObject(function(Type, Flag, Value, Selected)
		Esp.PlayerUtils.Settings.Health.Enabled = Value
		end, {
			{
			Type = "Toggle",
			Default = false,
			Flag = "Toggle"
		}, {
			Type = "Label",
			Text = "Show Healthbar"
		},
		})
	
		
		VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.Fullbright = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Fullbright"
			},
			})
		

		
		
		VisualsTab2:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.DeathBagESP = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Show Deathbags"
			},
			})
		




	
  -- // Silent Aim Tab // --

  local CombatTabR = CombatTab:Groupbox({
    Title = "Aimbot",
    Side = 1
})

CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
BlackoutSettings.SilentAimEnabled = Value
    end, {
        {
        Type = "Toggle",
        Default = false,
        Flag = "Toggle"
    }, {
        Type = "Label",
        Text = "Enable Silent Aim"
    }
    })


    CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
        BlackoutSettings.SilentAimFOVEnabled = Value
        end, {
            {
            Type = "Toggle",
            Default = false,
            Flag = "Toggle"
        }, {
            Type = "Label",
            Text = "Show FOV"
    },
        })

        CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.SilentAimRadius = Value
               end, {
                {
               Type = "Slider",
               Min = 50,
               Max = 1000,
               Default = 150,
               DecimalPlaces = 1,
               Format = "%s",
               Flag = "Distance"
            }, {
               Type = "Label",
               Text = "FOV Size"
            }
               })

               CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
                BlackoutSettings.SilentAimHitChance = Value
                   end, {
                    {
                   Type = "Slider",
                   Min = 0,
                   Max = 100,
                   Default = 100,
                   DecimalPlaces = 1,
                   Format = "%s",
                   Flag = "Hitchance"
                }, {
                   Type = "Label",
                   Text = "Hitchance"
                }
                   })


                   CombatTabR:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.SilentAimTargetPart = Value
                    end, {
                        {
                   Type = "Dropdown",
                   Text = "Head",
                   Items = {
                    "Head",
                    "HumanoidRootPart",
                    'Random'
                },
                Defaults = {
                    [1] = true,
                },
                Default = 1,
                SelectMultiple = false,
                CloseAfterSelection = true,
                NoStartCallback = true
            }
                    })
		
-- Modifications


	local CombatTab3 = CombatTab:Groupbox({
						Title = "Weapon Modifications",
					Side = 2
					})


					CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.NoRecoil = Value
						end, {
							{
							Type = "Toggle",
							Default = false,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "No Recoil"
						}
						})



			
									
			

						CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
			bps = Value
						end, {
							{
												Type = "Label",
												Text = "Bullets Per Shot:"
											   
											}, {
						
								
							   Type = "Slider",
							   Min = 1,
							   Max = 500,
							   Default = 15,
							   DecimalPlaces = 1,
							   Format = "%s",
							   Flag = "Distance"
							}
							   })
					
							   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
								local Names = {
									"AmmoTypes",
									"Swaping",
									"Reloading",
									"Firing",
								}
								
								local AllSettings = {}
								
								for i,v in ipairs(getgc(true)) do
									if typeof(v) ~= "table" then
										continue
									end
									local found = true
									for _, name in ipairs(Names) do
										if not rawget(v, name) then
											found = false
											break
										end
									end
								
									if not found then
										continue 
									end
								
									table.insert(AllSettings, v)
								end
								
								for i,Settings in ipairs(AllSettings) do
									local Modes = Settings.Modes
								
									for i,v in Modes do
										v.Automatic = true
									   v.Rounds = bps
									end
								end
							end, {
							
							{
								Type = "Button",
								Flag = "Nutonme"
							}, {
								Type = "Label",
								Text = "Apply to current weapon"
							}
							
							})

							
							CombatTab3:CreateObject(function(Type, Flag, Value, Selected)

							end, {
						
			
					{
						Type = "Information",
						Text = "Bullets per shot is currently in HEAVY testing and the value unapplies when you unequip your weapon.\n\nThis will be worked on in the future to work better, but currently this is the only method for BPS to be possible.\n\nA very high value will make your screen freeze for a couple seconds, tweak whats best for you.\n\nMaximum value will freeze your game for a couple of seconds, Feature may crash your client!"
					
					}
				})




-- Melee

  local CombatTab2 = CombatTab:Groupbox({
    Title = "Automatic Melee Exploits",
    Side = 2
})

CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
    BlackoutSettings.KillAura = Value
    end, {
        {
        Type = "Toggle",
        Default = false,
        Flag = "Toggle"
    }, {
        Type = "Label",
        Text = "Kill Aura"
    }
    })




	CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
		BlackoutSettings.KillAuraDistance = Value
	end, {
		{
							Type = "Label",
							Text = "Target distance:"
						   
						}, {
	
			
		   Type = "Slider",
		   Min = 1,
		   Max = 15,
		   Default = 15,
		   DecimalPlaces = 1,
		   Format = "%s",
		   Flag = "Distance"
		}
		   })



		


		   CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
			BlackoutSettings.KillAuraHeavy = Value
			end, {
				{
				Type = "Toggle",
				Default = false,
				Flag = "Toggle"
			}, {
				Type = "Label",
				Text = "Use Heavy Attacks"
			}
			})





			CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
				BlackoutSettings.KillAuraPlayers = Value
				end, {
					{
					Type = "Toggle",
					Default = false,
					Flag = "Toggle"
				}, {
					Type = "Label",
					Text = "Target Players"
				}
				})
	
	
				CombatTab2:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.KillAuraNPCs = Value
					end, {
						{
						Type = "Toggle",
						Default = false,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Target NPCs"
					}
					})

			

	
			local CombatTab3 = CombatTab:Groupbox({
				Title = "Autoshoot",
				Side = 1
			})

			CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
				BlackoutSettings.Autoshoot = Value
				end, {
					{
					Type = "Toggle",
					Default = false,
					Flag = "Toggle"
				}, {
					Type = "Label",
					Text = "Autoshoot"
				},

				{
					Type = "Information",
					Text = "Autoshoot is recommended to be used on good ping, due to blackout being very heavily ping based, some shots may not register. For the best performance, low ping is recommended.\n\nIf the autoshoot tracer does not show up anymore, that indicates that the server-side ammo is 0. Please shoot one shot from your weapon and then reload. "
					},

					{
					Type = "Dropdown",
					Text = "Head",
					Items = {
						"Head",
						"HumanoidRootPart",
					},
					Defaults = {
						[1] = true,
					},
					Default = 1,
					SelectMultiple = false,
					CloseAfterSelection = true,
					NoStartCallback = true,
					Callback = function(Type, Flag, Value, Selected)
						--BlackoutSettings.AutoshootHitPart = Value
					end
				}
			})
			




									
				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
					shootCooldown = Value
				end, {
					{
										Type = "Label",
										Text = "Time between shots:"
									   
									}, {
				
					   Type = "Slider",
					   Min = 0,
					   Max = 1,
					   Default = 0.08,
					   DecimalPlaces = 2,
					   Format = "%s",
					   Flag = "Distance"
					}
					   })


					   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
    
				
						
						-- Enable settings based on the Value
						if Value == "Penetrable" then
							BlackoutSettings.WallbangEnabled = true
						elseif Value == "Visible" then
							BlackoutSettings.WallbangEnabled = false
						end
					
					end, {
						{
							Type = "Dropdown",
							Text = "Fire Mode:",
							Items = {
								"Visible",
								"Penetrable"
							},
							Defaults = {
								[1] = true,
							},
							Default = 1,
							SelectMultiple = false,  -- Ensures only one option can be selected at a time
							CloseAfterSelection = true,
							NoStartCallback = true
						},
						{
							Type = "Information",
							Text = "Fire Mode - Controls the conditions in which you will autoshoot.\n\nVisible - Will shoot the enemy if they are visible.\n\nPenetrable - Will shoot enemies through walls, but sometimes can miss some shots if the penetration distance is set to a high value, 45 is recommended. Tweak if needed."
						}
					})
											





				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
		
					end, {
						{
						Type = "Toggle",
						Default = true,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Decrease Ammo"
					}, {
				
						Type = "Information",
						Text = "[AUTO-TOGGLED] Manipulates the serverside bullets. When toggling the feature, your weapon will shoot multiple bullets but it will take way less ammo from your actual magazine. It is heavily recommended to keep this feature toggled on at all times. "
					}
					})



									
				CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.AutoshootDistance = Value
					   end, {
	{
						Type = "Label",
						Text = "Target distance:"
					   
					}, {

					   Type = "Slider",
					   Min = 50,
					   Max = 5000,
					   Default = 350,
					   DecimalPlaces = 1,
					   Format = "%s",
					   Flag = "Distance"
					}
					   })


			
					   CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.WallbangDistance = Value
					end, {
						{
											Type = "Label",
											Text = "Penetration distance:"
										   
										}, {
						   Type = "Slider",
						   Min = 1,
						   Max = 100,
						   Default = 25,
						   DecimalPlaces = 1,
						   Format = "%s",
						   Flag = "Distance"
				
						}
						   })

			
			



										

									CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
										BlackoutSettings.TogglePlayers = Value
										end, {
											{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										}, {
											Type = "Label",
											Text = "Target Players"
										}
										})
			

								


										CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
											BlackoutSettings.ToggleNPCs = Value
											end, {
												{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											}, {
												Type = "Label",
												Text = "Target NPCs"
											}
											})
				

									CombatTab3:CreateObject(function(Type, Flag, Value, Selected)
							BlackoutSettings.BulletTracers = Value
							end, {
								{
								Type = "Toggle",
								Default = false,
								Flag = "Toggle"
							}, {
								Type = "Label",
								Text = "Visualize Fired Shots"
							}
							})
		
			
			
							local ExploitsTab2 = ExploitsTab:Groupbox({
								Title = "Combat Exploits",
								Side = 1
							})


							
							ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
								BlackoutSettings.AutoReload = Value
								end, {
									{
									Type = "Toggle",
									Default = false,
									Flag = "Toggle"
								}, {
									Type = "Label",
									Text = "Automatic Reload"
								},

								{
									Type = "Information",
									Text = "Automatically reloads the weapon with no animation when it detects that its less than the full magazine."
								}
								})
						

							ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
				
								end, {
									{
									Type = "Toggle",
									Default = false,
									Flag = "Toggle"
								}, {
									Type = "Label",
									Text = "Automatic Finish"
								},

								{
									Type = "Information",
									Text = "Automatically finishes players + npcs when they are downed within a 15 stud radius."
								}
								})



								ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
									-- You can handle the selected player here if needed
								end, {
									{
										Type = "Dropdown",
										Text = "Select Target:",
										
										-- Dynamically populate the Items list with the player names
										Items = (function()
											local playerList = {}
											local localPlayer = game.Players.LocalPlayer
								
											for _, player in ipairs(game.Players:GetPlayers()) do
												if player ~= localPlayer then  -- Exclude the local player
													table.insert(playerList, player.Name)
												end
											end
								
											return playerList
										end)(),
								
										Defaults = {
											[1] = true,
										},
										Default = 1,
										SelectMultiple = false,
										CloseAfterSelection = true,
										NoStartCallback = true
									},
								
								})
								
								ExploitsTab2:CreateObject(function(Type, Flag, Value, Selected)
									-- You can handle the selected player here if needed
								end, {
	
								{
									Type = "Button",
									Flag = "Nutonme"
								}, {
									Type = "Label",
									Text = "Teleport Throwable"
								}, {
										Type = "Information",
										Text = "Teleports throwables to a target, and you are automatically placed under the target. CURRENTLY EXTREMLEY BROKEN AND UNPRECISE!"
									}
								})




					
								local CharacterTab2 = ExploitsTab:Groupbox({
									Title = "Character Exploits",
									Side = 1
								})
		
		
								CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
									BlackoutSettings.InfiniteStamina = Value
									end, {
										{
										Type = "Toggle",
										Default = false,
										Flag = "Toggle"
									}, {
										Type = "Label",
										Text = "Exploit Stamina"
									}
									})

									CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
										if Flag == "Toggle" then
											BlackoutSettings.Fly = Value -- This sets the Fly toggle value
										elseif Flag == "Distance" then
											speed = Value -- This sets the speed value from the slider
										end
									end, {
										{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										},
										{
											Type = "Label",
											Text = "Player Fly"
										},
										{
											Type = "Slider",
											Min = 0,
											Max = 100,
											Default = 15,
											DecimalPlaces = 1,
											Format = "%s",
											Flag = "Distance"
										}
									})
									
							


									CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
										BlackoutSettings.Noclip = Value
										end, {
											{
											Type = "Toggle",
											Default = false,
											Flag = "Toggle"
										}, {
											Type = "Label",
											Text = "Player Noclip"
										}
										})
							
						

										CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
											if Flag == "Toggle" then
												BlackoutSettings.Walkspeed = Value -- This sets the Walkspeed toggle value
											elseif Flag == "Distance" then
												BlackoutSettings.WalkspeedValue = Value -- This sets the Walkspeed value from the slider
											end
										end, {
											{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											},
											{
												Type = "Label",
												Text = "Player Speed"
											},
											{
												Type = "Slider",
												Min = 1,
												Max = 100,
												Default = 50,
												DecimalPlaces = 1,
												Format = "%s",
												Flag = "Distance"
											}
										})
										
						
						
										   CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
											BlackoutSettings.InfiniteJump = Value
												end, {
													{
													Type = "Toggle",
													Default = false,
													Flag = "Toggle"
												}, {
													Type = "Label",
													Text = "Infinite Jump"
												}
											})
						
											CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
										if Value == true then
											LocalPlayer.Character.RagdollClient:Destroy()
										elseif Value == false then
										end
											end, {
												{
												Type = "Toggle",
												Default = false,
												Flag = "Toggle"
											}, {
												Type = "Label",
												Text = "No Fall Damage"
											}
											})
								
								
						
											CharacterTab2:CreateObject(function(Type, Flag, Value, Selected)
												if Value == true then
													LocalPlayer.Character.ScreenShake:Destroy()
												elseif Value == false then
												end
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "No Screen Shake"
													}
													})
		


													local AntiAim = ExploitsTab:Groupbox({
														Title = "Anti-Aim",
														Side = 2
													})


										
													AntiAim:CreateObject(function(Type, Flag, Value, Selected)
														
														   end, {
															{
															Type = "Toggle",
															Default = false,
															Flag = "Toggle"
														}, {
															Type = "Label",
															Text = "Enable Fake Angles"
													},
														})
									
														AntiAim:CreateObject(function(Type, Flag, Value, Selected)
													 
															   end, {
									
												   {
														Type = "Label",
														Text = "Mode"
													}, {
														Type = "Dropdown",
														Text = "",
														Items = {
															"Backwards",
															"Front",
															"Force Right",
															"Force Left"
														},
														Defaults = {
															[2] = true, -- "sure :3!!"
															[4] = true -- "mrrp mrrp mrewo mrwooo meoooow ^-^"
														},
														Default = 1,
														SelectMultiple = false,
														CloseAfterSelection = true,
														NoStartCallback = true
													}
													})
									
									
													AntiAim:CreateObject(function(Type, Flag, Value, Selected)
														
														   end, {
															{
													Type = "Slider",
													Min = 0,
													Max = 10,
													Default = 0.0,
													DecimalPlaces = 1,
													Format = "%s",
													Flag = "Yaw"
												}, {
													Type = "Label",
													Text = "Yaw"
												   
												},
											})
									
										AntiAim:CreateObject(function(Type, Flag, Value, Selected)
														
											end, {
											 {
									 Type = "Slider",
									 Min = 0,
									 Max = 10,
									 Default = 0.0,
									 DecimalPlaces = 1,
									 Format = "%s",
									 Flag = "Pitch"
									
									}, {
									 Type = "Label",
									 Text = "Pitch"
									
									},
									})
									
									AntiAim:CreateObject(function(Type, Flag, Value, Selected)
														
									end, {
									 {
									Type = "Slider",
									Min = 0,
									Max = 10,
									Default = 0.0,
									DecimalPlaces = 1,
									Format = "%s",
									Flag = "Roll"
									}, {
										Type = "Label",
										Text = "Roll"
									   
									   },
									})
											




				   local ExploitsTab3 = ExploitsTab:Groupbox({
					Title = "Server Exploits",
					Side = 2
				})
			
				ExploitsTab3:CreateObject(function(Type, Flag, Value, Selected)
					BlackoutSettings.FlingAll = Value
					end, {
						{
						Type = "Toggle",
						Default = false,
						Flag = "Toggle"
					}, {
						Type = "Label",
						Text = "Fling all"
					}
					})
		
		




					ExploitsTab3:CreateObject(function(Type, Flag, Value, Selected)
						BlackoutSettings.FlingAll = Value
						end, {
							{
							Type = "Toggle",
							Default = false,
							Flag = "Toggle"
						}, {
							Type = "Label",
							Text = "Kill all"
						}
						})
			
			
	
	




					
											local CharacterTab3 = ExploitsTab:Groupbox({
												Title = "Miscellaneous Exploits",
												Side = 2
											})



											CharacterTab3:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.AutoLockpick = Value
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "Instant Lockpick"
													}, {
														Type = "Information",
														Text = "Feature also allows you to have infinite lockpicks."
												
													}

												})
													
											CharacterTab3:CreateObject(function(Type, Flag, Value, Selected)
												BlackoutSettings.AutoLoot = Value
													end, {
														{
														Type = "Toggle",
														Default = false,
														Flag = "Toggle"
													}, {
														Type = "Label",
														Text = "Auto Loot"
													}
								
								
												})








					
												local CharacterTab4 = MiscTab:Groupbox({
													Title = "Player List",
													Side = 1
												})

												local CharacterTab5 = MiscTab:Groupbox({
													Title = "Other Miscellaneous",
													Side = 2
												})

							

												local following = false

												CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
													if Type == "Dropdown" then
														selectedPlayer = Value -- Store the selected player name
													end
												end, {
													{
														Type = "Dropdown",
														Text = "Select Player:",
														Items = (function()
															local playerList = {}
															for _, player in ipairs(game.Players:GetPlayers()) do
																if player ~= game.Players.LocalPlayer then
																	table.insert(playerList, player.Name)
																end
															end
															return playerList
														end)(),
														Defaults = { [1] = true },
														Default = 1,
														SelectMultiple = false,
														CloseAfterSelection = true,
														NoStartCallback = true
													},
												})
												
												
												
							
												
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
																if Type == "Toggle" then
																	following = Value
																	local targetPlayer = game.Players:FindFirstChild(selectedPlayer)
															
																	if following then
																		if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
																			workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
															
																			-- Create a loop to keep updating the camera's position
																			while following do
																				wait(0.01) -- Adjust the wait time as needed
																				if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
																					workspace.CurrentCamera.CFrame = CFrame.new(targetPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 10), targetPlayer.Character.HumanoidRootPart.Position)
																				else
																					break -- Exit the loop if the target no longer exists
																				end
																			end
																		end
																	else
																		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom -- Reset the camera
																	end
																end
															end, {
																{
																	Type = "Toggle",
																	Default = false,
																	Flag = "Toggle"
																}, {
																	Type = "Label",
																	Text = "View target"
																}
															})
					
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
												
															end, {
															{

															
																	Type = "Label",
																	Text = "Whitelisting"
																}
																
															})


															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
																if Type == "Dropdown" then
																	selectedPlayers = Value -- Store the selected player names
																end
															end, {
																{
																	Type = "Dropdown",
																	Text = "Select Player(s):",
																	Items = (function()
																		local playerList = {}
																		for _, player in ipairs(game.Players:GetPlayers()) do
																			if player ~= game.Players.LocalPlayer then
																				table.insert(playerList, player.Name)
																			end
																		end
																		return playerList
																	end)(),
																	Defaults = { [1] = true },
																	Default = 1,
																	SelectMultiple = true,
																	CloseAfterSelection = true,
																	NoStartCallback = true
																},
															})
															
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
																if Type == "Toggle" then
																	whitelistedPlayersAutoshoot[Selected] = Value
																end
															end, {
																{
																	Type = "Toggle",
																	Default = false,
																	Flag = "Toggle"
																}, {
																	Type = "Label",
																	Text = "Whitelist from Autoshoot"
																}
															})
															
															CharacterTab4:CreateObject(function(Type, Flag, Value, Selected)
																if Type == "Toggle" then
																	whitelistedPlayersSilentAim[Selected] = Value
																end
															end, {
																{
																	Type = "Toggle",
																	Default = false,
																	Flag = "Toggle"
																}, {
																	Type = "Label",
																	Text = "Whitelist from Silent Aim"
																}
															})

															CharacterTab5:CreateObject(function(Type, Flag, Value, Selected)
																local CoreGui = game:GetService("CoreGui")
																local ExperienceChat = CoreGui:FindFirstChild("ExperienceChat")
																
																if ExperienceChat then
																	local ChatInputBar = ExperienceChat.appLayout:FindFirstChild("chatInputBar")
																	local ChatWindow = ExperienceChat.appLayout:FindFirstChild("chatWindow")
																	
																	if ChatInputBar and ChatWindow then
																		-- Check the boolean value
																		if not Value then
																			-- Hide chat window and adjust input bar position
																			ChatWindow.Visible = false
																			ChatInputBar.Position = UDim2.new(0, 0, 0, 0) -- Adjust position as needed
																		else
																			-- Show chat window and adjust input bar position
																			ChatWindow.Visible = true
																			ChatInputBar.Position = UDim2.new(0, 0, 0, ChatWindow.Size.Y.Offset)
																		end
																	end
																end
																
																	end, {
																		{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Show Chat"
																	}
												
												
																})





																local CharacterTab6 = MiscTab:Groupbox({
																	Title = "Camouflage Settings",
																	Side = 2
																})
																
																
																CharacterTab6:CreateObject(function(Type, Flag, Value, Selected)
																BlackoutSettings.HideLevel = Value
																end, {
																	{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Mask Level"
																	}
																})
																
																
																
																CharacterTab6:CreateObject(function(Type, Flag, Value, Selected)
																BlackoutSettings.HideLeaderBoard = Value
																end, {
																	{
																		Type = "Toggle",
																		Default = false,
																		Flag = "Toggle"
																	}, {
																		Type = "Label",
																		Text = "Hide Leaderboard"
																	}
																})
																
																

																-- Services
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- Rejoin function
local function rejoinGame()
    local player = Players.LocalPlayer
    local placeId = game.PlaceId
    local jobId = game.JobId

    -- Rejoin the same server
    TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
end


				
CharacterTab5:CreateObject(function(Type, Flag, Value, Selected)
	rejoinGame()
end, {

{
	Type = "Button",
	Flag = "Nutonme"
}, {
	Type = "Label",
	Text = "Rejoin Server"
}

})




game.StarterGui:SetCore("SendNotification", {
    Title = "Kinetic";
    Text = "Loaded, UI Keybind: End";
    Icon = "rbxassetid://88195615011513";
    Duration = 5; 
    })
